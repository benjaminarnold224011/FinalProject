/*
Students' Names:      Benjamin Arnold, Thomas Wynne, Michael Kirkendoll
Course:               CSC242 Intro to Programming Concepts
Instructor:           Professor Rich Yonts
Assignment:           Assignment 5 â€” Streams Projects P8.2 and P8.7
File Name:            assign5.cpp
Date:                 Nov 23, 2025

Program Description
Purpose:
    This program completes two problems from Chapter 8.
    1) Spell check a file using a dictionary file such as /usr/share/dict/words.
    2) Encrypt or decrypt a text file using a keyword based monoalphabetic cipher.

User Interface:
    You can run with command line arguments or follow prompts.

    Spell check:
        assign5 spell <dictionary_path> <input_path>

    Cipher:
        assign5 crypt -k<KEYWORD> [-e | -d] <input_path> <output_path>

    If you run without arguments the program shows a small menu and asks for what it needs.

Program Output:
    Spell check prints each word from the input that is not found in the dictionary.
    Cipher writes the transformed text to the output file and shows a confirmation message.

Functional Specification
Inputs:
    Paths to files and a keyword for the cipher.
Processing:
    P8.2: Load dictionary words into a vector. Read input words. Clean and lowercase them.
          If a word is not in the dictionary vector, print it.
    P8.7: Build a 26 letter cipher order from the keyword. Map letters to encrypt or decrypt.
Outputs:
    List of unknown words for P8.2. A new file with encrypted or decrypted text for P8.7.

Course Outcomes Demonstrated:
    3) Use arrays (26 element letter maps) and vectors (dictionary words).
    5) Define and call functions and show value and reference parameters.

Source:
    Horstmann, C. S. (2017). Big C++: Late Objects, Enhanced eText (3rd ed.). Wiley.
===============================================================================

PSEUDOCODE (language agnostic)

MAIN
    if no command line arguments
        show menu
        if user chooses spell
            ask for dictionary file path
            ask for input file path
            runSpellCheck(dictionaryPath, inputPath)
        else if user chooses crypt
            ask for E or D
            ask for keyword
            ask for input file path
            ask for output file path
            runCrypt(mode, keyword, inputPath, outputPath)
        end if
        stop
    else
        if first argument is "spell"
            get dictionary_path and input_path
            runSpellCheck(dictionary_path, input_path)
        else if first argument is "crypt"
            read -k keyword and -e or -d and file paths
            runCrypt(mode, keyword, input_path, output_path)
        else
            print help
        end if
        stop
    end if

SPELL CHECK
    load dictionary file words into vector words (lowercase)
    open input file
    for each token in input
        w <- cleanWord(token)  // keep letters and one apostrophe, lowercase
        if w is not empty and w not in words
            print w
        end if
    end for

CIPHER
    keywordUpper <- normalize keyword to uppercase letters only
    keyOrder <- remove duplicates from keywordUpper, keep first occurrence
    for letter from 'Z' down to 'A'
        if letter not in keyOrder
            append letter to keyOrder
        end if
    end for
    make encMap[26] where plain 'A' + i maps to keyOrder[i]
    make decMap[26] which is the inverse map
    open input file and output file
    for each character ch in input
        if letter
            if mode is Encrypt then write encChar(ch) else write decChar(ch)
        else
            write ch as is
        end if
    end for

END PSEUDOCODE

*/

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cctype>
#include <limits>

// ----------------- Helper functions -----------------

// Make a lowercase copy of s
std::string toLowerCopy(const std::string& s) {
    std::string t = s;
    for (char& c : t) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
    return t;
}

// Clean a raw token into a simple word: keep letters and at most one middle apostrophe.
// Convert to lowercase. Trim apostrophes from ends.
std::string cleanWord(const std::string& raw) {
    std::string out;
    out.reserve(raw.size());
    int apostrophes = 0;
    for (char ch : raw) {
        unsigned char u = static_cast<unsigned char>(ch);
        if (std::isalpha(u)) {
            out.push_back(static_cast<char>(std::tolower(u)));
        } else if (ch == '\'' && apostrophes == 0) {
            out.push_back(ch);
            apostrophes = 1;
        }
    }
    if (!out.empty() && out.front() == '\'') out.erase(out.begin());
    if (!out.empty() && out.back() == '\'') out.pop_back();
    return out;
}

// Linear search in a vector of strings.
// Returns true if target is present.
bool containsWord(const std::vector<std::string>& words, const std::string& target) {
    for (const std::string& w : words) {
        if (w == target) return true;
    }
    return false;
}

// Load every token from a text file as a lowercase word into outWords.
// Returns false on file error.
bool loadDictionaryLower(const std::string& dictionaryPath, std::vector<std::string>& outWords) {
    std::ifstream in(dictionaryPath);
    if (!in) return false;
    std::string token;
    while (in >> token) {
        outWords.push_back(toLowerCopy(token));
    }
    return true;
}

// ----------------- P8.2 Spell Check -----------------

void runSpellCheck(const std::string& dictionaryPath, const std::string& inputPath) {
    std::vector<std::string> dictionaryWords;
    if (!loadDictionaryLower(dictionaryPath, dictionaryWords)) {
        std::cerr << "Could not open dictionary file: " << dictionaryPath << "\n";
        return;
    }

    std::ifstream in(inputPath);
    if (!in) {
        std::cerr << "Could not open input file: " << inputPath << "\n";
        return;
    }

    std::cout << "\nWords not found in dictionary:\n";

    std::string token;
    while (in >> token) {
        std::string w = cleanWord(token);
        if (!w.empty() && !containsWord(dictionaryWords, w)) {
            std::cout << w << "\n";
        }
    }
}

